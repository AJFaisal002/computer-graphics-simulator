# -*- coding: utf-8 -*-
"""Group-02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V7ZLcrSMkSqvyVLyruVbroi0gx9qR7Db
"""

import matplotlib.pyplot as plt
import numpy as np

"""## 1. DDA Line Drawing Algorithm"""

def dda_line(x0, y0, x1, y1):

    points = []

    dx = x1 - x0
    dy = y1 - y0

    # Handle vertical line
    if dx == 0:
        step = 1 if y1 >= y0 else -1
        for y in range(y0, y1 + step, step):
            points.append((x0, y))
        return points

    m = dy / dx   # slope

    x = x0
    y = y0

    points.append((round(x), round(y)))

    # -------------------------------------------------
    # Case A: |m| <= 1  (Shallow slope → x is driving)
    # -------------------------------------------------
    if abs(m) <= 1:

        step = 1 if x1 >= x0 else -1

        while round(x) != x1:
            x = x + step
            y = y + m * step   # y(k+1) = y(k) + m
            points.append((round(x), round(y)))

    # -------------------------------------------------
    # Case B: |m| > 1  (Steep slope → y is driving)
    # -------------------------------------------------
    else:

        step = 1 if y1 >= y0 else -1

        while round(y) != y1:
            y = y + step
            x = x + (1 / m) * step   # x(k+1) = x(k) + 1/m
            points.append((round(x), round(y)))

    return points

"""## 2. Bresenham Line Drawing Algorithm"""

def bresenham_line(x0, y0, x1, y1):

    points = []

    dx = x1 - x0
    dy = y1 - y0

    abs_dx = abs(dx)
    abs_dy = abs(dy)

    sx = 1 if dx >= 0 else -1
    sy = 1 if dy >= 0 else -1

    if abs_dx >= abs_dy:

        p = 2 * abs_dy - abs_dx

        x = x0
        y = y0

        for _ in range(abs_dx + 1):
            points.append((x, y))

            if p < 0:
                p = p + 2 * abs_dy
            else:
                y = y + sy
                p = p + 2 * abs_dy - 2 * abs_dx

            x = x + sx

    else:

        p = 2 * abs_dx - abs_dy

        x = x0
        y = y0

        for _ in range(abs_dy + 1):
            points.append((x, y))

            if p < 0:
                p = p + 2 * abs_dx
            else:
                x = x + sx
                p = p + 2 * abs_dx - 2 * abs_dy

            y = y + sy

    return points

"""## 3. Midpoint Circle Algorithm"""

def midpoint_circle(xc, yc, r):

    points = []

    x = 0
    y = r
    D = 1 - r

    def add_points(x, y):
        pts = [
            (xc + x, yc + y),
            (xc - x, yc + y),
            (xc + x, yc - y),
            (xc - x, yc - y),
            (xc + y, yc + x),
            (xc - y, yc + x),
            (xc + y, yc - x),
            (xc - y, yc - x)
        ]
        for p in pts:
            points.append(p)

    while x <= y:
        add_points(x, y)

        if D < 0:
            D = D + 2 * x + 1
        else:
            D = D + 2 * (x - y) + 1
            y -= 1

        x += 1

    final = []
    seen = set()
    for p in points:
        if p not in seen:
            final.append(p)
            seen.add(p)

    return final

def get_int(prompt, default):
    val = input(f"{prompt} (default {default}): ")
    return int(val) if val.strip() != "" else default

"""## Line Inputs"""

x0 = get_int("Enter x0", 2)
y0 = get_int("Enter y0", 3)
x1 = get_int("Enter x1", 12)
y1 = get_int("Enter y1", 8)

"""## Circle Inputs"""

xc = get_int("Enter circle center x", 10)
yc = get_int("Enter circle center y", 10)
r  = get_int("Enter radius", 6)

dda_pts = dda_line(x0, y0, x1, y1)
bres_pts = bresenham_line(x0, y0, x1, y1)
circle_pts = midpoint_circle(xc, yc, r)

plt.figure(figsize=(12, 4))

# DDA
plt.subplot(1, 3, 1)
x, y = zip(*dda_pts)
plt.scatter(x, y)
plt.title("DDA Line")
plt.gca().set_aspect('equal', adjustable='box')
plt.grid()

# Bresenham
plt.subplot(1, 3, 2)
x, y = zip(*bres_pts)
plt.scatter(x, y)
plt.title("Bresenham Line")
plt.gca().set_aspect('equal', adjustable='box')
plt.grid()

# Circle
plt.subplot(1, 3, 3)
x, y = zip(*circle_pts)
plt.scatter(x, y)
plt.title("Midpoint Circle")
plt.gca().set_aspect('equal', adjustable='box')
plt.grid()

plt.show()

